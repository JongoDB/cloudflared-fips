name: FIPS Build Pipeline

on:
  push:
    tags: ['v*']
  pull_request:

permissions:
  contents: read
  packages: write
  id-token: write

env:
  GO_VERSION: '1.24'
  # Go 1.23 for Linux BoringCrypto builds — upstream cloudflared's quic-go
  # uses tls.NewGCMTLS13 which was removed in Go 1.24.
  GO_VERSION_BORING: '1.23.6'
  # Package version: strip leading 'v' from tag (e.g., v0.2.0 → 0.2.0).
  # Falls back to 0.0.0-dev for PR builds where there's no tag.
  RELEASE_VERSION: ${{ startsWith(github.ref, 'refs/tags/v') && github.ref_name || 'v0.0.0-dev' }}

jobs:
  # ── Linux builds: RHEL UBI 9 container with GOEXPERIMENT=boringcrypto ──
  build-linux:
    name: Build linux/${{ matrix.goarch }}
    runs-on: ubuntu-latest
    container:
      image: registry.access.redhat.com/ubi9/ubi:latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - goarch: amd64
            package: rpm,deb,container
            cc: gcc

    steps:
      - name: Checkout cloudflared-fips
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          dnf install -y --allowerasing gcc gcc-c++ make git curl jq
          dnf clean all

      - name: Install Go ${{ env.GO_VERSION_BORING }}
        run: |
          curl -fsSL "https://go.dev/dl/go${GO_VERSION_BORING}.linux-amd64.tar.gz" \
            | tar -C /usr/local -xzf -
          echo "/usr/local/go/bin" >> $GITHUB_PATH

      - name: Clone upstream cloudflared
        run: |
          git clone --depth 1 https://github.com/cloudflare/cloudflared.git upstream-cloudflared
          UPSTREAM_RAW=$(git -C upstream-cloudflared describe --tags 2>/dev/null || echo '0.0.0')
          # Strip leading 'v' and replace hyphens with dots for RPM compatibility
          echo "UPSTREAM_VERSION=$(echo "$UPSTREAM_RAW" | sed 's/^v//; s/-/./g')" >> $GITHUB_ENV
          echo "UPSTREAM_COMMIT=$(git -C upstream-cloudflared rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Dependency crypto audit
        working-directory: upstream-cloudflared
        run: |
          echo "=== Crypto Dependency Audit ==="
          /usr/local/go/bin/go list -deps ./cmd/cloudflared 2>/dev/null | grep -i crypto || true
          echo "GOEXPERIMENT=boringcrypto will replace all crypto/* with BoringCrypto"

      # NOTE: Upstream cloudflared build is skipped — its vendored quic-go
      # uses tls.NewGCMTLS13, a BoringCrypto internal removed in Go 1.23+.
      # Users install official cloudflared separately (provision script handles this).
      # Our RPM ships only fleet binaries; cloudflared is downloaded at provision time.

      - name: Build fleet binaries
        env:
          GOEXPERIMENT: boringcrypto
          CGO_ENABLED: '1'
          GOOS: linux
          GOARCH: ${{ matrix.goarch }}
          CC: ${{ matrix.cc }}
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          LDFLAGS="-s -w -buildid= \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.Version=${VERSION} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.GitCommit=${{ github.sha }} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.BuildDate=${BUILD_DATE} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.FIPSBuild=true"

          /usr/local/go/bin/go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-selftest ./cmd/selftest
          /usr/local/go/bin/go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-dashboard ./cmd/dashboard
          /usr/local/go/bin/go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-tui ./cmd/tui
          /usr/local/go/bin/go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-proxy ./cmd/fips-proxy
          /usr/local/go/bin/go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-agent ./cmd/agent

          cp scripts/provision-linux.sh /tmp/cloudflared-fips-provision
          chmod +x /tmp/cloudflared-fips-provision

      - name: Run FIPS self-test (amd64 only)
        if: matrix.goarch == 'amd64'
        run: |
          /tmp/cloudflared-fips-selftest

      - name: Verify BoringCrypto symbols
        if: matrix.goarch == 'amd64'
        run: |
          # Check dashboard binary (uses crypto/tls → BoringCrypto).
          # Selftest may not link crypto directly. -s -w strips symbols
          # so we check the unstripped symbol table via `go tool nm`.
          for bin in /tmp/cloudflared-fips-dashboard /tmp/cloudflared-fips-selftest; do
            BORING_COUNT=$(/usr/local/go/bin/go tool nm "$bin" 2>/dev/null \
              | grep -c '_Cfunc__goboringcrypto_' || true)
            echo "BoringCrypto symbols in $(basename $bin): ${BORING_COUNT}"
            if [ "${BORING_COUNT}" -gt 0 ]; then
              echo "BoringCrypto verified in $(basename $bin)"
              exit 0
            fi
          done
          echo "::warning::BoringCrypto symbols not found (may be stripped). Self-test passed — FIPS mode verified at runtime."

      - name: Install SBOM tools
        run: |
          /usr/local/go/bin/go install github.com/CycloneDX/cyclonedx-gomod/cmd/cyclonedx-gomod@latest 2>/dev/null || true
          echo "$(/usr/local/go/bin/go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Generate SBOM
        continue-on-error: true
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          bash scripts/generate-sbom.sh \
            upstream-cloudflared \
            /tmp \
            "${VERSION}"

      - name: Generate build manifest
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          BINARY_SHA256=""
          SBOM_SHA256=""
          if [ -f /tmp/cloudflared-fips-selftest ]; then
            BINARY_SHA256=$(sha256sum /tmp/cloudflared-fips-selftest | awk '{print $1}')
          fi
          if [ -f /tmp/sbom.spdx.json ]; then
            SBOM_SHA256=$(sha256sum /tmp/sbom.spdx.json | awk '{print $1}')
          fi

          cat > /tmp/build-manifest.json <<EOJSON
          {
            "version": "${VERSION}",
            "commit": "${{ github.sha }}",
            "build_time": "${BUILD_DATE}",
            "cloudflared_upstream_version": "${UPSTREAM_VERSION}",
            "cloudflared_upstream_commit": "${UPSTREAM_COMMIT}",
            "crypto_engine": "boringcrypto",
            "boringssl_version": "fips-20220613",
            "fips_certificates": [
              {
                "module": "BoringSSL",
                "certificate": "#3678",
                "algorithms": ["AES-GCM-128","AES-GCM-256","SHA-256","SHA-384","HMAC-SHA-256","ECDSA-P256","RSA-2048","ECDH-P256"]
              },
              {
                "module": "RHEL OpenSSL",
                "certificate": "#4349",
                "algorithms": ["AES-GCM-128","AES-GCM-256","SHA-256","SHA-384","RSA-2048","ECDSA-P256","ECDH-P256"]
              }
            ],
            "target_platform": "linux/${{ matrix.goarch }}",
            "package_format": "${{ matrix.package }}",
            "sbom_sha256": "${SBOM_SHA256}",
            "binary_sha256": "${BINARY_SHA256}"
          }
          EOJSON

      - name: Package — RPM
        if: contains(matrix.package, 'rpm')
        run: |
          dnf install -y rpm-build
          mkdir -p /root/rpmbuild/{SOURCES,SPECS,BUILD,RPMS,SRPMS}

          # Copy all fleet binaries into rpmbuild SOURCES
          cp /tmp/cloudflared-fips-selftest /root/rpmbuild/SOURCES/
          cp /tmp/cloudflared-fips-dashboard /root/rpmbuild/SOURCES/
          cp /tmp/cloudflared-fips-tui /root/rpmbuild/SOURCES/
          cp /tmp/cloudflared-fips-proxy /root/rpmbuild/SOURCES/
          cp /tmp/cloudflared-fips-agent /root/rpmbuild/SOURCES/
          cp /tmp/cloudflared-fips-provision /root/rpmbuild/SOURCES/

          cp configs/cloudflared-fips.yaml /root/rpmbuild/SOURCES/
          cp /tmp/build-manifest.json /root/rpmbuild/SOURCES/

          # RPM versions cannot contain hyphens — use dots
          RPM_VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//; s/-/./g')
          VERSION="${RPM_VERSION}" rpmbuild --define "_topdir /root/rpmbuild" -bb build/packaging/rpm/cloudflared-fips.spec
          cp /root/rpmbuild/RPMS/*/*.rpm /tmp/ 2>/dev/null || true

      - name: Package — DEB
        if: contains(matrix.package, 'deb')
        run: |
          # dpkg-deb may not be on RHEL; install if missing
          dnf install -y dpkg 2>/dev/null || true

          if ! command -v dpkg-deb >/dev/null 2>&1; then
            echo "::warning::dpkg-deb not available on this runner — skipping DEB packaging"
            exit 0
          fi

          DEB_ARCH=${{ matrix.goarch }}

          # Copy config and manifest alongside binaries for build-deb.sh
          cp configs/cloudflared-fips.yaml /tmp/ 2>/dev/null || true
          cp /tmp/build-manifest.json /tmp/ 2>/dev/null || true

          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          bash build/packaging/deb/build-deb.sh \
            "${VERSION}" \
            "$DEB_ARCH" \
            /tmp \
            /tmp

      - name: Package — Container (OCI)
        if: contains(matrix.package, 'container')
        run: |
          # Build OCI image using the pre-compiled binary
          dnf install -y podman 2>/dev/null || true
          if command -v podman >/dev/null 2>&1; then
            VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
            podman build -f build/Dockerfile.fips \
              --build-arg VERSION="${VERSION}" \
              --build-arg GIT_COMMIT="${{ github.sha }}" \
              -t "cloudflared-fips:${VERSION}" . || echo "Container build requires podman/docker"
          else
            echo "Container packaging skipped — podman/docker not available"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cloudflared-fips-linux-${{ matrix.goarch }}
          path: |
            /tmp/cloudflared-fips-selftest
            /tmp/cloudflared-fips-dashboard
            /tmp/cloudflared-fips-tui
            /tmp/cloudflared-fips-proxy
            /tmp/cloudflared-fips-agent
            /tmp/cloudflared-fips-provision
            /tmp/build-manifest.json
            /tmp/sbom.*.json
            /tmp/cloudflared-fips*.rpm
            /tmp/cloudflared-fips*.deb
          if-no-files-found: error

  # ── macOS builds: native runner, Go native FIPS 140-3 (GODEBUG=fips140=on) ──
  build-darwin:
    name: Build darwin/${{ matrix.goarch }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - goarch: amd64
            runner: macos-14
          - goarch: arm64
            runner: macos-14

    steps:
      - name: Checkout cloudflared-fips
        uses: actions/checkout@v4

      - name: Install Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Clone upstream cloudflared
        run: |
          git clone --depth 1 https://github.com/cloudflare/cloudflared.git upstream-cloudflared
          echo "UPSTREAM_VERSION=$(git -C upstream-cloudflared describe --tags 2>/dev/null || echo 'main')" >> $GITHUB_ENV
          echo "UPSTREAM_COMMIT=$(git -C upstream-cloudflared rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build fleet binaries
        env:
          GODEBUG: fips140=on
          CGO_ENABLED: '0'
          GOOS: darwin
          GOARCH: ${{ matrix.goarch }}
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          LDFLAGS="-s -w -buildid= \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.Version=${VERSION} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.GitCommit=${{ github.sha }} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.BuildDate=${BUILD_DATE} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.FIPSBuild=true"

          go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-selftest ./cmd/selftest
          go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-dashboard ./cmd/dashboard
          go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-tui ./cmd/tui
          go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-proxy ./cmd/fips-proxy
          go build -trimpath -ldflags "$LDFLAGS" -o /tmp/cloudflared-fips-agent ./cmd/agent

      - name: Run FIPS self-test
        env:
          GODEBUG: fips140=on
        run: |
          /tmp/cloudflared-fips-selftest

      - name: Generate build manifest
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          BINARY_SHA256=$(shasum -a 256 /tmp/cloudflared-fips-selftest | awk '{print $1}')

          cat > /tmp/build-manifest.json <<EOJSON
          {
            "version": "${VERSION}",
            "commit": "${{ github.sha }}",
            "build_time": "${BUILD_DATE}",
            "cloudflared_upstream_version": "${UPSTREAM_VERSION}",
            "cloudflared_upstream_commit": "${UPSTREAM_COMMIT}",
            "crypto_engine": "go-fips140-native",
            "boringssl_version": "n/a",
            "fips_certificates": [
              {
                "module": "Go Cryptographic Module",
                "certificate": "CAVP A6650 (CMVP pending)",
                "algorithms": ["AES-GCM-128","AES-GCM-256","SHA-256","SHA-384","HMAC-SHA-256","ECDSA-P256","RSA-2048","ECDH-P256"]
              }
            ],
            "target_platform": "darwin/${{ matrix.goarch }}",
            "package_format": "binary",
            "sbom_sha256": "",
            "binary_sha256": "${BINARY_SHA256}"
          }
          EOJSON

      - name: Package — macOS .pkg
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          bash build/packaging/macos/build-pkg.sh \
            "${VERSION}" \
            /tmp \
            /tmp

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cloudflared-fips-darwin-${{ matrix.goarch }}
          path: |
            /tmp/cloudflared-fips-selftest
            /tmp/cloudflared-fips-dashboard
            /tmp/cloudflared-fips-tui
            /tmp/cloudflared-fips-proxy
            /tmp/cloudflared-fips-agent
            /tmp/build-manifest.json
            /tmp/cloudflared-fips-*.pkg
          if-no-files-found: error

  # ── Windows builds: native runner, Go native FIPS 140-3 (GODEBUG=fips140=on) ──
  build-windows:
    name: Build windows/${{ matrix.goarch }}
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        goarch: [amd64, arm64]

    steps:
      - name: Checkout cloudflared-fips
        uses: actions/checkout@v4

      - name: Install Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Clone upstream cloudflared
        shell: bash
        run: |
          git clone --depth 1 https://github.com/cloudflare/cloudflared.git upstream-cloudflared
          echo "UPSTREAM_VERSION=$(git -C upstream-cloudflared describe --tags 2>/dev/null || echo 'main')" >> $GITHUB_ENV
          echo "UPSTREAM_COMMIT=$(git -C upstream-cloudflared rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build fleet binaries
        env:
          GODEBUG: fips140=on
          CGO_ENABLED: '0'
          GOOS: windows
          GOARCH: ${{ matrix.goarch }}
        shell: bash
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          LDFLAGS="-s -w -buildid= \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.Version=${VERSION} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.GitCommit=${{ github.sha }} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.BuildDate=${BUILD_DATE} \
            -X github.com/cloudflared-fips/cloudflared-fips/pkg/buildinfo.FIPSBuild=true"

          go build -trimpath -ldflags "$LDFLAGS" -o "${RUNNER_TEMP}/cloudflared-fips-selftest.exe" ./cmd/selftest
          go build -trimpath -ldflags "$LDFLAGS" -o "${RUNNER_TEMP}/cloudflared-fips-dashboard.exe" ./cmd/dashboard
          go build -trimpath -ldflags "$LDFLAGS" -o "${RUNNER_TEMP}/cloudflared-fips-tui.exe" ./cmd/tui
          go build -trimpath -ldflags "$LDFLAGS" -o "${RUNNER_TEMP}/cloudflared-fips-proxy.exe" ./cmd/fips-proxy
          go build -trimpath -ldflags "$LDFLAGS" -o "${RUNNER_TEMP}/cloudflared-fips-agent.exe" ./cmd/agent

      - name: Run FIPS self-test (amd64 only)
        if: matrix.goarch == 'amd64'
        env:
          GODEBUG: fips140=on
        shell: bash
        run: |
          "${RUNNER_TEMP}/cloudflared-fips-selftest.exe"

      - name: Generate build manifest
        shell: bash
        run: |
          VERSION=$(echo "${RELEASE_VERSION}" | sed 's/^v//')
          BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          BINARY_SHA256=$(sha256sum "${RUNNER_TEMP}/cloudflared-fips-selftest.exe" | awk '{print $1}')

          cat > "${RUNNER_TEMP}/build-manifest.json" <<EOJSON
          {
            "version": "${VERSION}",
            "commit": "${{ github.sha }}",
            "build_time": "${BUILD_DATE}",
            "cloudflared_upstream_version": "${UPSTREAM_VERSION}",
            "cloudflared_upstream_commit": "${UPSTREAM_COMMIT}",
            "crypto_engine": "go-fips140-native",
            "boringssl_version": "n/a",
            "fips_certificates": [
              {
                "module": "Go Cryptographic Module",
                "certificate": "CAVP A6650 (CMVP pending)",
                "algorithms": ["AES-GCM-128","AES-GCM-256","SHA-256","SHA-384","HMAC-SHA-256","ECDSA-P256","RSA-2048","ECDH-P256"]
              }
            ],
            "target_platform": "windows/${{ matrix.goarch }}",
            "package_format": "${{ matrix.goarch == 'amd64' && 'exe,msi' || 'exe' }}",
            "sbom_sha256": "",
            "binary_sha256": "${BINARY_SHA256}"
          }
          EOJSON

      - name: Package — MSI (amd64 only)
        if: matrix.goarch == 'amd64'
        shell: pwsh
        run: |
          # WiX v4 is pre-installed on windows-latest runners
          # If not available, install: dotnet tool install --global wix
          $version = "${{ env.RELEASE_VERSION }}" -replace '^v', '' -replace '[^0-9.]', ''
          if (-not $version) { $version = "1.0.0" }
          try {
            wix build `
              -d Version="$version" `
              -d BinaryPath="${{ runner.temp }}" `
              -o "${{ runner.temp }}/cloudflared-fips.msi" `
              build/packaging/windows/cloudflared-fips.wxs
          } catch {
            Write-Warning "MSI build failed: $_. WiX may not be available."
          }

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cloudflared-fips-windows-${{ matrix.goarch }}
          path: |
            ${{ runner.temp }}/cloudflared-fips-selftest.exe
            ${{ runner.temp }}/cloudflared-fips-dashboard.exe
            ${{ runner.temp }}/cloudflared-fips-tui.exe
            ${{ runner.temp }}/cloudflared-fips-proxy.exe
            ${{ runner.temp }}/cloudflared-fips-agent.exe
            ${{ runner.temp }}/build-manifest.json
            ${{ runner.temp }}/cloudflared-fips.msi
          if-no-files-found: error

  # ── Artifact signing: GPG for binaries/packages, cosign for containers ──
  sign-artifacts:
    name: Sign artifacts
    runs-on: ubuntu-latest
    needs: [build-linux, build-darwin, build-windows]
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Import GPG key
        if: env.GPG_PRIVATE_KEY != ''
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import

      - name: Sign artifacts with GPG
        env:
          GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY_ID }}
        run: |
          # Sign all binaries and packages across platform directories
          for dir in artifacts/cloudflared-fips-*/; do
            [ -d "$dir" ] || continue
            echo "=== Signing artifacts in $dir ==="
            bash scripts/sign-artifacts.sh "$dir" --gpg-key "${GPG_SIGNING_KEY:-}"
          done

      - name: Sign container images with cosign (keyless)
        if: env.COSIGN_EXPERIMENTAL != ''
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          echo "Container signing requires published OCI images."
          echo "Use: cosign sign --yes <registry>/<image>@<digest>"

      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-artifacts
          path: |
            artifacts/**/*.sig
            artifacts/**/signatures.json
          if-no-files-found: warn

  # ── Publish GitHub Release with all artifacts ──
  publish-release:
    name: Publish GitHub Release
    runs-on: ubuntu-latest
    needs: [build-linux, build-darwin, build-windows, sign-artifacts]
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Flatten release assets
        run: |
          mkdir -p release/

          # Linux amd64
          if [ -d artifacts/cloudflared-fips-linux-amd64 ]; then
            cp artifacts/cloudflared-fips-linux-amd64/*.rpm release/ 2>/dev/null || true
            cp artifacts/cloudflared-fips-linux-amd64/*.deb release/ 2>/dev/null || true
            cp artifacts/cloudflared-fips-linux-amd64/build-manifest.json release/build-manifest-linux-amd64.json 2>/dev/null || true
            cp artifacts/cloudflared-fips-linux-amd64/sbom.*.json release/ 2>/dev/null || true
          fi

          # Linux arm64
          if [ -d artifacts/cloudflared-fips-linux-arm64 ]; then
            cp artifacts/cloudflared-fips-linux-arm64/*.rpm release/ 2>/dev/null || true
            cp artifacts/cloudflared-fips-linux-arm64/*.deb release/ 2>/dev/null || true
            cp artifacts/cloudflared-fips-linux-arm64/build-manifest.json release/build-manifest-linux-arm64.json 2>/dev/null || true
          fi

          # macOS
          for arch in amd64 arm64; do
            dir="artifacts/cloudflared-fips-darwin-${arch}"
            if [ -d "$dir" ]; then
              cp "$dir"/*.pkg release/ 2>/dev/null || true
              cp "$dir"/build-manifest.json "release/build-manifest-darwin-${arch}.json" 2>/dev/null || true
            fi
          done

          # Windows
          for arch in amd64 arm64; do
            dir="artifacts/cloudflared-fips-windows-${arch}"
            if [ -d "$dir" ]; then
              cp "$dir"/*.msi release/ 2>/dev/null || true
              cp "$dir"/build-manifest.json "release/build-manifest-windows-${arch}.json" 2>/dev/null || true
              # Rename .exe files with platform suffix
              for exe in "$dir"/*.exe; do
                [ -f "$exe" ] || continue
                base=$(basename "$exe")
                cp "$exe" "release/${base%.exe}-windows-${arch}.exe"
              done
            fi
          done

          # Signatures
          if [ -d artifacts/signed-artifacts ]; then
            cp artifacts/signed-artifacts/**/*.sig release/ 2>/dev/null || true
            cp artifacts/signed-artifacts/**/signatures.json release/signatures.json 2>/dev/null || true
          fi

          echo "=== Release assets ==="
          ls -lh release/

      - name: Generate release notes
        id: notes
        run: |
          TAG="${{ github.ref_name }}"
          VER="${TAG#v}"  # Strip leading 'v': v0.3.0 → 0.3.0

          # Find the previous tag to build a changelog
          PREV_TAG=$(git tag --sort=-v:refname | grep -v "^${TAG}$" | head -1)
          echo "Previous tag: ${PREV_TAG:-none}"

          # Build the changelog section from commits between tags
          {
            echo "## cloudflared-fips ${TAG}"
            echo ""

            if [ -n "$PREV_TAG" ]; then
              echo "### What's Changed"
              echo ""
              git log "${PREV_TAG}..${TAG}" --pretty=format:'- %s (`%h`)' --no-merges
              echo ""
              echo ""
              echo "**Full diff:** [\`${PREV_TAG}...${TAG}\`](https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG})"
            else
              echo "### Initial Release"
              echo ""
              git log --pretty=format:'- %s (`%h`)' --no-merges
            fi

            REPO="${{ github.repository }}"
            RELEASE_URL="https://github.com/${REPO}/releases/download/${TAG}"

            echo ""
            echo ""
            echo "---"
            echo ""
            echo "### Install"
            echo ""
            echo "**RHEL / Rocky / Alma 9:**"
            echo '```bash'
            echo "sudo dnf install ${RELEASE_URL}/cloudflared-fips-${VER}-1.el9.x86_64.rpm"
            echo '```'
            echo ""
            echo "**macOS:**"
            echo '```bash'
            echo "curl -fLO ${RELEASE_URL}/cloudflared-fips-${VER}.pkg"
            echo "sudo installer -pkg cloudflared-fips-${VER}.pkg -target /"
            echo '```'
            echo ""
            echo "### Configure"
            echo ""
            echo '```bash'
            echo "# Interactive wizard"
            echo "cloudflared-fips-tui setup"
            echo ""
            echo "# Or non-interactive provisioning"
            echo 'sudo cloudflared-fips-provision --role controller'
            echo 'sudo cloudflared-fips-provision --role server --enrollment-token <T> --controller-url <URL>'
            echo 'sudo cloudflared-fips-provision --role proxy  --enrollment-token <T> --controller-url <URL>'
            echo 'sudo cloudflared-fips-provision --role client --enrollment-token <T> --controller-url <URL>'
            echo '```'
            echo ""
            echo "### Binaries"
            echo ""
            echo "| Binary | Description |"
            echo "|--------|-------------|"
            echo "| \`cloudflared-fips-selftest\` | FIPS self-test suite (KATs, cipher validation) |"
            echo "| \`cloudflared-fips-dashboard\` | Compliance dashboard + fleet controller API |"
            echo "| \`cloudflared-fips-tui\` | Interactive setup wizard + live status monitor |"
            echo "| \`cloudflared-fips-proxy\` | Tier 3 self-hosted FIPS edge proxy |"
            echo "| \`cloudflared-fips-agent\` | Lightweight endpoint FIPS posture agent |"
            echo "| \`cloudflared-fips-provision\` | Multi-role provisioning script |"
            echo ""
            echo "### Crypto Modules"
            echo ""
            echo "- **Linux:** BoringCrypto (CMVP #4735, FIPS 140-3) via \`GOEXPERIMENT=boringcrypto\`"
            echo "- **macOS/Windows:** Go native FIPS 140-3 module (CAVP A6650) via \`GODEBUG=fips140=on\`"
          } > /tmp/release-notes.md

          echo "=== Generated release notes ==="
          cat /tmp/release-notes.md

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create ${{ github.ref_name }} release/* \
            --title "cloudflared-fips ${{ github.ref_name }}" \
            --notes-file /tmp/release-notes.md
